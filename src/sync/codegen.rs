use crate::{
    config,
    pack::rect::{Rect, Size},
};
use anyhow::bail;
use std::{
    collections::BTreeMap,
    path::{Path, PathBuf},
};

#[derive(Clone)]
pub enum Node {
    Table(BTreeMap<String, Node>),
    String(String),
    Content(String),
    #[allow(dead_code)]
    Number(u64),
    AtlasSprite(AtlasSpriteData),
}

#[derive(Clone)]
pub struct AtlasSpriteData {
    pub image: String,
    pub rect: Rect,
    pub size: Size,
    pub trimmed: bool,
    pub sprite_source_size: Option<Rect>,
}

pub enum Language {
    TypeScript,
    Luau,
}

pub fn create_node(source: &BTreeMap<PathBuf, Node>, config: &config::Codegen) -> Node {
    let mut root = Node::Table(BTreeMap::new());

    for (path, node) in source {
        let value = match node {
            Node::String(s) if config.content => Node::Content(s.clone()),
            other => other.clone(),
        };

        match config.style {
            config::CodegenStyle::Nested => {
                let components = normalize_path_components(
                    path,
                    config.strip_extensions,
                    &config.asset_naming_convention,
                );
                insert_nested(&mut root, &components, value);
            }
            config::CodegenStyle::Flat => {
                let key = normalize_path_string(
                    path,
                    config.strip_extensions,
                    &config.asset_naming_convention,
                );
                insert_flat(&mut root, &key, value);
            }
        }
    }

    root
}

fn normalize_path_components(
    path: &Path,
    strip_extensions: bool,
    convention: &config::NamingConvention,
) -> Vec<String> {
    let mut components: Vec<String> = Vec::new();
    let total_components = path.iter().count();

    for (i, comp) in path.iter().enumerate() {
        let component_str = if i == total_components - 1 && strip_extensions {
            let as_path = Path::new(comp);
            if let Some(stem) = as_path.file_stem() {
                stem.to_string_lossy().to_string()
            } else {
                comp.to_string_lossy().to_string()
            }
        } else {
            comp.to_string_lossy().to_string()
        };

        components.push(convert_name(&component_str, convention));
    }
    components
}

fn normalize_path_string(
    path: &Path,
    strip_extensions: bool,
    convention: &config::NamingConvention,
) -> String {
    let path_str = if strip_extensions
        && let (Some(file_name), Some(parent)) = (path.file_name(), path.parent())
        && let Some(stem) = Path::new(file_name).file_stem()
    {
        let parent_str = parent.to_string_lossy();
        if parent_str.is_empty() || parent_str == "." {
            stem.to_string_lossy().into_owned()
        } else {
            format!("{}/{}", parent_str, stem.to_string_lossy())
        }
    } else {
        path.to_string_lossy().into_owned()
    };

    convert_name(&path_str, convention)
}

fn insert_flat(node: &mut Node, key: &str, value: Node) {
    match node {
        Node::Table(map) => {
            map.insert(key.into(), value);
        }
        _ => {
            *node = Node::Table(BTreeMap::new());
            if let Node::Table(map) = node {
                map.insert(key.into(), value);
            }
        }
    }
}

fn insert_nested(node: &mut Node, components: &[String], value: Node) {
    if !matches!(node, Node::Table(_)) {
        *node = Node::Table(BTreeMap::new());
    }

    if components.is_empty() {
        return;
    }

    if let Node::Table(map) = node {
        let component = &components[0];

        if components.len() == 1 {
            map.insert(component.clone(), value);
        } else {
            let next_node = map
                .entry(component.clone())
                .or_insert_with(|| Node::Table(BTreeMap::new()));

            if !matches!(next_node, Node::Table(_)) {
                *next_node = Node::Table(BTreeMap::new());
            }

            insert_nested(next_node, &components[1..], value);
        }
    }
}

pub fn generate_code(
    lang: Language,
    name: &str,
    node: &Node,
    input_naming_convention: &config::NamingConvention,
) -> anyhow::Result<String> {
    if !matches!(node, Node::Table(_)) {
        bail!("Root node must be a Table");
    }

    let converted_name = convert_name(name, input_naming_convention);

    Ok(match lang {
        Language::TypeScript => generate_typescript(&converted_name, node),
        Language::Luau => generate_luau(&converted_name, node),
    })
}

fn generate_typescript(name: &str, node: &Node) -> String {
    let body = generate_ts_node(node, 0);
    format!(
        "// This file is automatically @generated by Asphalt.\n// It is not intended for manual editing.\ndeclare const {name}: {body}\n\nexport = {name}"
    )
}

fn generate_ts_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                result.push_str("readonly ");
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("\"{k}\"")
                };
                result.push_str(&k);
                result.push_str(": ");
                result.push_str(&generate_ts_node(v, indent + 1));
                result.push_str(";\n");
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(_) => "string".to_string(),
        Node::Content(_) => "Content".to_string(),
        Node::Number(_) => "number".to_string(),
        Node::AtlasSprite(_) => {
            let mut result = String::from("{\n");
            let tab = "\t".repeat(indent + 1);
            result.push_str(&format!("{}readonly image: string;\n", tab));
            result.push_str(&format!("{}readonly imageRectOffset: Vector2;\n", tab));
            result.push_str(&format!("{}readonly imageRectSize: Vector2;\n", tab));
            result.push_str(&format!("{}readonly sourceSize?: Vector2;\n", tab));
            result.push_str(&format!("{}readonly spriteSourceOffset?: Vector2;\n", tab));
            result.push_str(&format!("{}readonly trimmed: boolean;\n", tab));
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
    }
}

fn generate_luau(name: &str, node: &Node) -> String {
    let body = generate_luau_node(node, 0);
    format!(
        "-- This file is automatically @generated by Asphalt.\n-- It is not intended for manual editing.\nlocal {name} = {body}\n\nreturn {name}"
    )
}

fn generate_luau_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("[\"{k}\"]")
                };
                result.push_str(&k);
                result.push_str(" = ");
                result.push_str(&generate_luau_node(v, indent + 1));
                result.push_str(",\n");
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(s) => format!("\"{s}\""),
        Node::Content(s) => format!("Content.fromUri(\"{s}\")"),
        Node::Number(n) => format!("{n}"),
        Node::AtlasSprite(data) => {
            let tab = "\t".repeat(indent + 1);
            let mut result = String::from("{\n");
            result.push_str(&format!("{}image = \"{}\",\n", tab, data.image));
            result.push_str(&format!(
                "{}imageRectOffset = Vector2.new({}, {}),\n",
                tab, data.rect.x, data.rect.y
            ));
            result.push_str(&format!(
                "{}imageRectSize = Vector2.new({}, {}),\n",
                tab, data.rect.width, data.rect.height
            ));
            result.push_str(&format!("{}trimmed = {},\n", tab, data.trimmed));
            result.push_str(&format!(
                "{}sourceSize = Vector2.new({}, {}),\n",
                tab, data.size.width, data.size.height
            ));
            if let Some(sprite_source) = data.sprite_source_size {
                result.push_str(&format!(
                    "{}spriteSourceOffset = Vector2.new({}, {}),\n",
                    tab, sprite_source.x, sprite_source.y
                ));
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
    }
}

fn is_valid_ident_char_start(value: char) -> bool {
    value.is_ascii_alphabetic() || value == '_'
}

fn is_valid_ident_char(value: char) -> bool {
    value.is_ascii_alphanumeric() || value == '_'
}

fn is_valid_identifier(value: &str) -> bool {
    let mut chars = value.chars();

    match chars.next() {
        Some(first) => {
            if !is_valid_ident_char_start(first) {
                return false;
            }
        }
        None => return false,
    }

    chars.all(is_valid_ident_char)
}

fn convert_name(value: &str, convention: &config::NamingConvention) -> String {
    match convention {
        config::NamingConvention::SnakeCase => to_snake_case(value),
        config::NamingConvention::CamelCase => to_camel_case(value),
        config::NamingConvention::PascalCase => to_pascal_case(value),
        config::NamingConvention::ScreamingSnakeCase => to_screaming_snake_case(value),
        config::NamingConvention::Preserve => to_preserve(value),
    }
}

fn split_into_words(value: &str) -> Vec<String> {
    let mut words = Vec::new();
    let mut current_word = String::new();

    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() {
            current_word.push(ch);
        } else if !current_word.is_empty() {
            words.push(current_word.clone());
            current_word.clear();
        }
    }

    if !current_word.is_empty() {
        words.push(current_word);
    }

    words
}

fn to_snake_case(value: &str) -> String {
    let words = split_into_words(value);
    let mut result = words.join("_").to_ascii_lowercase();

    if result.is_empty() || result.starts_with(|c: char| c.is_ascii_digit()) {
        result.insert(0, '_');
    }

    result
}

fn to_camel_case(value: &str) -> String {
    let starts_with_invalid = value
        .chars()
        .next()
        .is_none_or(|c| !is_valid_ident_char_start(c));

    let words = split_into_words(value);
    let mut result = String::new();

    for (i, word) in words.iter().enumerate() {
        if i == 0 {
            result.push_str(&word.to_ascii_lowercase());
        } else {
            let mut chars = word.chars();
            if let Some(first) = chars.next() {
                result.push(first.to_ascii_uppercase());
                result.push_str(&chars.as_str().to_ascii_lowercase());
            }
        }
    }

    if result.is_empty() || starts_with_invalid {
        result.insert(0, '_');
    }

    result
}

fn to_pascal_case(value: &str) -> String {
    let starts_with_invalid = value
        .chars()
        .next()
        .is_none_or(|c| !is_valid_ident_char_start(c));

    let words = split_into_words(value);
    let mut result = String::new();

    for word in words {
        let mut chars = word.chars();
        if let Some(first) = chars.next() {
            result.push(first.to_ascii_uppercase());
            result.push_str(&chars.as_str().to_ascii_lowercase());
        }
    }

    if result.is_empty() || starts_with_invalid {
        result.insert(0, '_');
    }

    result
}

fn to_screaming_snake_case(value: &str) -> String {
    let words = split_into_words(value);
    let mut result = words.join("_").to_ascii_uppercase();

    if result.is_empty() || result.starts_with(|c: char| c.is_ascii_digit()) {
        result.insert(0, '_');
    }

    result
}

fn to_preserve(value: &str) -> String {
    let mut result = String::with_capacity(value.len());
    let mut chars = value.chars();

    if let Some(first) = chars.next() {
        if is_valid_ident_char_start(first) {
            result.push(first);
        } else if first.is_ascii_digit() {
            result.push('_');
            result.push(first);
        } else {
            result.push('_');
        }
    }

    for ch in chars {
        if is_valid_ident_char(ch) {
            result.push(ch);
        } else {
            result.push('_');
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::pack::rect::{Rect, Size};

    fn make_test_node() -> Node {
        let mut inner_map = BTreeMap::new();
        inner_map.insert("foo".to_string(), Node::String("bar".to_string()));
        inner_map.insert("baz".to_string(), Node::Number(42));
        let inner_node = Node::Table(inner_map);

        let mut root_inner = BTreeMap::new();
        root_inner.insert("qux".to_string(), inner_node);
        root_inner.insert("fred".to_string(), Node::String("world".to_string()));
        root_inner.insert("waldo".to_string(), Node::Content("garply".to_string()));

        Node::Table(root_inner)
    }

    fn make_atlas_sprite_node(trimmed: bool) -> Node {
        Node::AtlasSprite(AtlasSpriteData {
            image: "rbxassetid://123456789".to_string(),
            rect: Rect::new(32, 64, 128, 128),
            size: Size::new(128, 128),
            trimmed,
            sprite_source_size: if trimmed {
                Some(Rect::new(8, 16, 112, 96))
            } else {
                None
            },
        })
    }

    fn make_mixed_nodes() -> Node {
        let mut map = BTreeMap::new();
        map.insert(
            "regular_image".to_string(),
            Node::String("rbxassetid://111".to_string()),
        );
        map.insert("trimmed_sprite".to_string(), make_atlas_sprite_node(true));
        map.insert(
            "untrimmed_sprite".to_string(),
            make_atlas_sprite_node(false),
        );
        Node::Table(map)
    }

    #[test]
    fn test_typescript_codegen() {
        let root_node = make_test_node();
        let code = generate_code(
            Language::TypeScript,
            "name",
            &root_node,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_luau_codegen() {
        let root_node = make_test_node();
        let code = generate_code(
            Language::Luau,
            "name",
            &root_node,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_luau_trimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(true));
        let root = Node::Table(map);
        let code = generate_code(
            Language::Luau,
            "sprite",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_luau_untrimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(false));
        let root = Node::Table(map);
        let code = generate_code(
            Language::Luau,
            "sprite",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_typescript_trimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(true));
        let root = Node::Table(map);
        let code = generate_code(
            Language::TypeScript,
            "sprite",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_typescript_untrimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(false));
        let root = Node::Table(map);
        let code = generate_code(
            Language::TypeScript,
            "sprite",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_mixed_nodes_luau() {
        let mixed_node = make_mixed_nodes();
        let code = generate_code(
            Language::Luau,
            "assets",
            &mixed_node,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_mixed_nodes_typescript() {
        let mixed_node = make_mixed_nodes();
        let code = generate_code(
            Language::TypeScript,
            "assets",
            &mixed_node,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_with_edge_values() {
        let sprite = Node::AtlasSprite(AtlasSpriteData {
            image: "rbxassetid://0".to_string(),
            rect: Rect::new(0, 0, 1024, 1024),
            size: Size::new(2048, 2048),
            trimmed: true,
            sprite_source_size: Some(Rect::new(512, 512, 1024, 1024)),
        });
        let mut map = BTreeMap::new();
        map.insert("edge_case".to_string(), sprite);
        let root = Node::Table(map);
        let code = generate_code(
            Language::Luau,
            "edge_case",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_naming_conventions() {
        assert_eq!(
            convert_name("character-art", &config::NamingConvention::SnakeCase),
            "character_art"
        );
        assert_eq!(
            convert_name("character-art", &config::NamingConvention::CamelCase),
            "characterArt"
        );
        assert_eq!(
            convert_name("character-art", &config::NamingConvention::PascalCase),
            "CharacterArt"
        );
        assert_eq!(
            convert_name(
                "character-art",
                &config::NamingConvention::ScreamingSnakeCase
            ),
            "CHARACTER_ART"
        );
        assert_eq!(
            convert_name("character-art", &config::NamingConvention::Preserve),
            "character_art"
        );
    }

    #[test]
    fn test_naming_edge_cases() {
        assert_eq!(
            convert_name("123invalid", &config::NamingConvention::CamelCase),
            "_123invalid"
        );
        assert_eq!(
            convert_name("-starts-with-hyphen", &config::NamingConvention::CamelCase),
            "_startsWithHyphen"
        );
        assert_eq!(
            convert_name("has spaces", &config::NamingConvention::PascalCase),
            "HasSpaces"
        );
        assert_eq!(
            convert_name("special!@#chars", &config::NamingConvention::SnakeCase),
            "special_chars"
        );
    }

    #[test]
    fn test_codegen_with_hyphenated_name() {
        let mut map = BTreeMap::new();
        map.insert(
            "test".to_string(),
            Node::String("rbxassetid://123".to_string()),
        );
        let root = Node::Table(map);

        let luau_code = generate_code(
            Language::Luau,
            "character-art",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        assert!(luau_code.contains("local characterArt ="));
        assert!(luau_code.contains("return characterArt"));

        let ts_code = generate_code(
            Language::TypeScript,
            "image-ids",
            &root,
            &config::NamingConvention::CamelCase,
        )
        .unwrap();
        assert!(ts_code.contains("declare const imageIds:"));
        assert!(ts_code.contains("export = imageIds"));
    }
}
