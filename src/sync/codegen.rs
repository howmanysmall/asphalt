use crate::{
    config,
    pack::rect::{Rect, Size},
};
use anyhow::bail;
use std::{
    collections::BTreeMap,
    path::{Path, PathBuf},
};

#[derive(Clone)]
pub enum Node {
    Table(BTreeMap<String, Node>),
    String(String),
    Content(String),
    #[allow(dead_code)]
    Number(u64),
    AtlasSprite(AtlasSpriteData),
}

#[derive(Clone)]
pub struct AtlasSpriteData {
    pub image: String,
    pub rect: Rect,
    pub size: Size,
    pub trimmed: bool,
    pub sprite_source_size: Option<Rect>,
}

pub enum Language {
    TypeScript,
    Luau,
}

pub fn create_node(source: &BTreeMap<PathBuf, Node>, config: &config::Codegen) -> Node {
    let mut root = Node::Table(BTreeMap::new());

    for (path, node) in source {
        let value = match node {
            Node::String(s) if config.content => Node::Content(s.clone()),
            other => other.clone(),
        };

        match config.style {
            config::CodegenStyle::Nested => {
                let components = normalize_path_components(path, config.strip_extensions);
                insert_nested(&mut root, &components, value);
            }
            config::CodegenStyle::Flat => {
                let key = normalize_path_string(path, config.strip_extensions);
                insert_flat(&mut root, &key, value);
            }
        }
    }

    root
}

fn normalize_path_components(path: &Path, strip_extensions: bool) -> Vec<String> {
    let mut components: Vec<String> = Vec::new();
    let total_components = path.iter().count();

    for (i, comp) in path.iter().enumerate() {
        if i == total_components - 1 && strip_extensions {
            let as_path = Path::new(comp);
            if let Some(stem) = as_path.file_stem() {
                components.push(stem.to_string_lossy().to_string());
                continue;
            }
        }
        components.push(comp.to_string_lossy().to_string());
    }
    components
}

fn normalize_path_string(path: &Path, strip_extensions: bool) -> String {
    if strip_extensions
        && let (Some(file_name), Some(parent)) = (path.file_name(), path.parent())
        && let Some(stem) = Path::new(file_name).file_stem()
    {
        let parent_str = parent.to_string_lossy();
        return if parent_str.is_empty() || parent_str == "." {
            stem.to_string_lossy().into_owned()
        } else {
            format!("{}/{}", parent_str, stem.to_string_lossy())
        };
    }
    path.to_string_lossy().into_owned()
}

fn insert_flat(node: &mut Node, key: &str, value: Node) {
    match node {
        Node::Table(map) => {
            map.insert(key.into(), value);
        }
        _ => {
            *node = Node::Table(BTreeMap::new());
            if let Node::Table(map) = node {
                map.insert(key.into(), value);
            }
        }
    }
}

fn insert_nested(node: &mut Node, components: &[String], value: Node) {
    if !matches!(node, Node::Table(_)) {
        *node = Node::Table(BTreeMap::new());
    }

    if components.is_empty() {
        return;
    }

    if let Node::Table(map) = node {
        let component = &components[0];

        if components.len() == 1 {
            map.insert(component.clone(), value);
        } else {
            let next_node = map
                .entry(component.clone())
                .or_insert_with(|| Node::Table(BTreeMap::new()));

            if !matches!(next_node, Node::Table(_)) {
                *next_node = Node::Table(BTreeMap::new());
            }

            insert_nested(next_node, &components[1..], value);
        }
    }
}

pub fn generate_code(lang: Language, name: &str, node: &Node) -> anyhow::Result<String> {
    if !matches!(node, Node::Table(_)) {
        bail!("Root node must be a Table");
    }

    Ok(match lang {
        Language::TypeScript => generate_typescript(name, node),
        Language::Luau => generate_luau(name, node),
    })
}

fn generate_typescript(name: &str, node: &Node) -> String {
    let body = generate_ts_node(node, 0);
    format!(
        "// This file is automatically @generated by Asphalt.\n// It is not intended for manual editing.\ndeclare const {name}: {body}\n\nexport = {name}"
    )
}

fn generate_ts_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                result.push_str("readonly ");
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("\"{k}\"")
                };
                result.push_str(&k);
                result.push_str(": ");
                result.push_str(&generate_ts_node(v, indent + 1));
                result.push_str(";\n");
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(_) => "string".to_string(),
        Node::Content(_) => "Content".to_string(),
        Node::Number(_) => "number".to_string(),
        Node::AtlasSprite(_) => {
            let mut result = String::from("{\n");
            let tab = "\t".repeat(indent + 1);
            result.push_str(&format!("{}readonly image: string;\n", tab));
            result.push_str(&format!("{}readonly imageRectOffset: Vector2;\n", tab));
            result.push_str(&format!("{}readonly imageRectSize: Vector2;\n", tab));
            result.push_str(&format!("{}readonly sourceSize?: Vector2;\n", tab));
            result.push_str(&format!("{}readonly spriteSourceOffset?: Vector2;\n", tab));
            result.push_str(&format!("{}readonly trimmed: boolean;\n", tab));
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
    }
}

fn generate_luau(name: &str, node: &Node) -> String {
    let body = generate_luau_node(node, 0);
    format!(
        "-- This file is automatically @generated by Asphalt.\n-- It is not intended for manual editing.\nlocal {name} = {body}\n\nreturn {name}"
    )
}

fn generate_luau_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("[\"{k}\"]")
                };
                result.push_str(&k);
                result.push_str(" = ");
                result.push_str(&generate_luau_node(v, indent + 1));
                result.push_str(",\n");
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(s) => format!("\"{s}\""),
        Node::Content(s) => format!("Content.fromUri(\"{s}\")"),
        Node::Number(n) => format!("{n}"),
        Node::AtlasSprite(data) => {
            let tab = "\t".repeat(indent + 1);
            let mut result = String::from("{\n");
            result.push_str(&format!("{}image = \"{}\",\n", tab, data.image));
            result.push_str(&format!(
                "{}imageRectOffset = Vector2.new({}, {}),\n",
                tab, data.rect.x, data.rect.y
            ));
            result.push_str(&format!(
                "{}imageRectSize = Vector2.new({}, {}),\n",
                tab, data.rect.width, data.rect.height
            ));
            result.push_str(&format!("{}trimmed = {},\n", tab, data.trimmed));
            result.push_str(&format!(
                "{}sourceSize = Vector2.new({}, {}),\n",
                tab, data.size.width, data.size.height
            ));
            if let Some(sprite_source) = data.sprite_source_size {
                result.push_str(&format!(
                    "{}spriteSourceOffset = Vector2.new({}, {}),\n",
                    tab, sprite_source.x, sprite_source.y
                ));
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
    }
}

fn is_valid_ident_char_start(value: char) -> bool {
    value.is_ascii_alphabetic() || value == '_'
}

fn is_valid_ident_char(value: char) -> bool {
    value.is_ascii_alphanumeric() || value == '_'
}

fn is_valid_identifier(value: &str) -> bool {
    let mut chars = value.chars();

    match chars.next() {
        Some(first) => {
            if !is_valid_ident_char_start(first) {
                return false;
            }
        }
        None => return false,
    }

    chars.all(is_valid_ident_char)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::pack::rect::{Rect, Size};

    fn make_test_node() -> Node {
        let mut inner_map = BTreeMap::new();
        inner_map.insert("foo".to_string(), Node::String("bar".to_string()));
        inner_map.insert("baz".to_string(), Node::Number(42));
        let inner_node = Node::Table(inner_map);

        let mut root_inner = BTreeMap::new();
        root_inner.insert("qux".to_string(), inner_node);
        root_inner.insert("fred".to_string(), Node::String("world".to_string()));
        root_inner.insert("waldo".to_string(), Node::Content("garply".to_string()));

        Node::Table(root_inner)
    }

    fn make_atlas_sprite_node(trimmed: bool) -> Node {
        Node::AtlasSprite(AtlasSpriteData {
            image: "rbxassetid://123456789".to_string(),
            rect: Rect::new(32, 64, 128, 128),
            size: Size::new(128, 128),
            trimmed,
            sprite_source_size: if trimmed {
                Some(Rect::new(8, 16, 112, 96))
            } else {
                None
            },
        })
    }

    fn make_mixed_nodes() -> Node {
        let mut map = BTreeMap::new();
        map.insert("regular_image".to_string(), Node::String("rbxassetid://111".to_string()));
        map.insert("trimmed_sprite".to_string(), make_atlas_sprite_node(true));
        map.insert("untrimmed_sprite".to_string(), make_atlas_sprite_node(false));
        Node::Table(map)
    }

    #[test]
    fn test_typescript_codegen() {
        let root_node = make_test_node();
        let code = generate_code(Language::TypeScript, "name", &root_node).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_luau_codegen() {
        let root_node = make_test_node();
        let code = generate_code(Language::Luau, "name", &root_node).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_luau_trimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(true));
        let root = Node::Table(map);
        let code = generate_code(Language::Luau, "sprite", &root).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_luau_untrimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(false));
        let root = Node::Table(map);
        let code = generate_code(Language::Luau, "sprite", &root).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_typescript_trimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(true));
        let root = Node::Table(map);
        let code = generate_code(Language::TypeScript, "sprite", &root).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_typescript_untrimmed() {
        let mut map = BTreeMap::new();
        map.insert("sprite".to_string(), make_atlas_sprite_node(false));
        let root = Node::Table(map);
        let code = generate_code(Language::TypeScript, "sprite", &root).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_mixed_nodes_luau() {
        let mixed_node = make_mixed_nodes();
        let code = generate_code(Language::Luau, "assets", &mixed_node).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_mixed_nodes_typescript() {
        let mixed_node = make_mixed_nodes();
        let code = generate_code(Language::TypeScript, "assets", &mixed_node).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_atlas_sprite_with_edge_values() {
        let sprite = Node::AtlasSprite(AtlasSpriteData {
            image: "rbxassetid://0".to_string(),
            rect: Rect::new(0, 0, 1024, 1024),
            size: Size::new(2048, 2048),
            trimmed: true,
            sprite_source_size: Some(Rect::new(512, 512, 1024, 1024)),
        });
        let mut map = BTreeMap::new();
        map.insert("edge_case".to_string(), sprite);
        let root = Node::Table(map);
        let code = generate_code(Language::Luau, "edge_case", &root).unwrap();
        insta::assert_snapshot!(code);
    }
}
