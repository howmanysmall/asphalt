use crate::pack::rect::{Rect, Size};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Complete atlas manifest containing all sprite information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AtlasManifest {
    pub input_name: String,
    pub sprites: HashMap<String, SpriteInfo>,
    pub pages: Vec<PageInfo>,
    pub created_at: String,
    pub options_hash: String,
}

/// Information about a single sprite in the atlas
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpriteInfo {
    /// The name of the sprite (usually filename without extension)
    pub name: String,
    /// Rectangle defining the sprite's position and size in the atlas
    pub rect: Rect,
    /// Original size of the sprite before any processing
    pub source_size: Size,
    /// Whether the sprite was trimmed (transparent borders removed)
    pub trimmed: bool,
    /// If trimmed, the rectangle of the original sprite that was kept
    pub sprite_source_size: Option<Rect>,
    /// Which atlas page this sprite is on
    pub page_index: usize,
}

/// Information about an atlas page
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageInfo {
    pub index: usize,
    pub filename: String,
    pub size: Size,
    pub sprite_count: usize,
}

#[allow(dead_code)]
impl AtlasManifest {
    pub fn new(input_name: String) -> Self {
        Self {
            input_name,
            sprites: HashMap::new(),
            pages: Vec::new(),
            created_at: chrono::Utc::now().to_rfc3339(),
            options_hash: String::new(),
        }
    }

    pub fn add_sprite(&mut self, sprite_info: SpriteInfo) {
        self.sprites.insert(sprite_info.name.clone(), sprite_info);
    }

    #[allow(dead_code)]
    pub fn add_page(&mut self, page_info: PageInfo) {
        self.pages.push(page_info);
    }

    #[allow(dead_code)]
    pub fn set_options_hash(&mut self, hash: String) {
        self.options_hash = hash;
    }

    #[allow(dead_code)]
    pub fn sprite_count(&self) -> usize {
        self.sprites.len()
    }

    #[allow(dead_code)]
    pub fn page_count(&self) -> usize {
        self.pages.len()
    }

    /// Generate Luau code for the atlas
    pub fn generate_luau(&self, asset_id: Option<u64>) -> String {
        let mut code = String::new();
        code.push_str("-- Generated by Asphalt\n");
        code.push_str("-- Do not edit this file manually\n\n");
        code.push_str("return {\n");

        for (name, sprite) in &self.sprites {
            let asset_ref = if let Some(id) = asset_id {
                format!("\"rbxassetid://{}\"", id)
            } else {
                "\"rbxassetid://0\"".to_string()
            };

            code.push_str(&format!("    [\"{}\"] = {{\n", name));
            code.push_str(&format!("        image = {},\n", asset_ref));
            code.push_str(&format!(
                "        imageRectOffset = Vector2.new({}, {}),\n",
                sprite.rect.x, sprite.rect.y
            ));
            code.push_str(&format!(
                "        imageRectSize = Vector2.new({}, {}),\n",
                sprite.rect.width, sprite.rect.height
            ));
            code.push_str(&format!("        trimmed = {},\n", sprite.trimmed));
            code.push_str(&format!(
                "        sourceSize = Vector2.new({}, {}),\n",
                sprite.source_size.width, sprite.source_size.height
            ));

            if let Some(sprite_source) = sprite.sprite_source_size {
                code.push_str(&format!(
                    "        spriteSourceOffset = Vector2.new({}, {}),\n",
                    sprite_source.x, sprite_source.y
                ));
            }

            code.push_str("    },\n");
        }

        code.push_str("}\n");
        code
    }

    /// Generate TypeScript definitions for the atlas
    pub fn generate_typescript(&self) -> String {
        let mut code = String::new();
        code.push_str("// Generated by Asphalt\n");
        code.push_str("// Do not edit this file manually\n\n");

        // Type definitions
        code.push_str("export interface Sprite {\n");
        code.push_str("    readonly image: string;\n");
        code.push_str("    readonly imageRectOffset: Vector2;\n");
        code.push_str("    readonly imageRectSize: Vector2;\n");
        code.push_str("    readonly sourceSize: Vector2;\n");
        code.push_str("    readonly spriteSourceOffset?: Vector2;\n");
        code.push_str("    readonly trimmed: boolean;\n");
        code.push_str("}\n\n");

        code.push_str("export type Atlas = {\n");
        for name in self.sprites.keys() {
            code.push_str(&format!("    readonly \"{}\": Sprite;\n", name));
        }
        code.push_str("};\n\n");

        // Default export with actual data
        code.push_str("const atlas: Atlas = {\n");
        for (name, sprite) in &self.sprites {
            code.push_str(&format!("    \"{}\": {{\n", name));
            code.push_str("        image: \"rbxassetid://0\",\n");
            code.push_str(&format!(
                "        imageRectOffset: new Vector2({}, {}),\n",
                sprite.rect.x, sprite.rect.y
            ));
            code.push_str(&format!(
                "        imageRectSize: new Vector2({}, {}),\n",
                sprite.rect.width, sprite.rect.height
            ));
            code.push_str(&format!(
                "        sourceSize: new Vector2({}, {}),\n",
                sprite.source_size.width, sprite.source_size.height
            ));

            if let Some(sprite_source) = sprite.sprite_source_size {
                code.push_str(&format!(
                    "        spriteSourceOffset: new Vector2({}, {}),\n",
                    sprite_source.x, sprite_source.y
                ));
            }

            code.push_str(&format!("        trimmed: {},\n", sprite.trimmed));
            code.push_str("    },\n");
        }
        code.push_str("};\n\n");
        code.push_str("export default atlas;\n");

        code
    }

    /// Serialize the manifest as JSON
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }

    /// Deserialize the manifest from JSON
    #[allow(dead_code)]
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_manifest() -> AtlasManifest {
        let mut manifest = AtlasManifest::new("test_input".to_string());

        let sprite_info = SpriteInfo {
            name: "test_sprite".to_string(),
            rect: Rect::new(0, 0, 64, 64),
            source_size: Size::new(64, 64),
            trimmed: false,
            sprite_source_size: None,
            page_index: 0,
        };

        manifest.add_sprite(sprite_info);

        let page_info = PageInfo {
            index: 0,
            filename: "test_input-sheet-0.png".to_string(),
            size: Size::new(512, 512),
            sprite_count: 1,
        };

        manifest.add_page(page_info);
        manifest
    }

    #[test]
    fn test_manifest_creation() {
        let manifest = create_test_manifest();
        assert_eq!(manifest.input_name, "test_input");
        assert_eq!(manifest.sprite_count(), 1);
        assert_eq!(manifest.page_count(), 1);
    }

    #[test]
    fn test_luau_generation() {
        let manifest = create_test_manifest();
        let luau = manifest.generate_luau(Some(123456));

        assert!(luau.contains("rbxassetid://123456"));
        assert!(luau.contains("test_sprite"));
        assert!(luau.contains("imageRectOffset = Vector2.new(0, 0)"));
        assert!(luau.contains("imageRectSize = Vector2.new(64, 64)"));
        assert!(luau.contains("sourceSize = Vector2.new(64, 64)"));
        assert!(luau.contains("trimmed = false"));
    }

    #[test]
    fn test_typescript_generation() {
        let manifest = create_test_manifest();
        let typescript = manifest.generate_typescript();

        assert!(typescript.contains("export interface Sprite"));
        assert!(typescript.contains("export type Atlas"));
        assert!(typescript.contains("test_sprite"));
        assert!(typescript.contains("imageRectOffset: new Vector2(0, 0)"));
        assert!(typescript.contains("imageRectSize: new Vector2(64, 64)"));
        assert!(typescript.contains("sourceSize: new Vector2(64, 64)"));
        assert!(typescript.contains("trimmed: false"));
    }

    #[test]
    fn test_json_serialization() {
        let manifest = create_test_manifest();
        let json = manifest.to_json().unwrap();
        let deserialized = AtlasManifest::from_json(&json).unwrap();

        assert_eq!(manifest.input_name, deserialized.input_name);
        assert_eq!(manifest.sprite_count(), deserialized.sprite_count());
        assert_eq!(manifest.page_count(), deserialized.page_count());
    }
}
