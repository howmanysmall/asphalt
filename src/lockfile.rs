use anyhow::{Context, Result, bail};
use blake3::Hasher;
use fs_err::tokio as fs;
use serde::{Deserialize, Serialize};
use std::{
    collections::BTreeMap,
    path::{Path, PathBuf},
};

pub const FILE_NAME: &str = "asphalt.lock.toml";

#[derive(Debug, Serialize, Deserialize)]
pub struct Lockfile {
    version: u32,
    inputs: BTreeMap<String, BTreeMap<String, LockfileEntry>>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LockfileEntry {
    pub asset_id: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sprite_info: Option<SpriteInfo>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SpriteInfo {
    pub rect: crate::pack::rect::Rect,
    pub source_size: crate::pack::rect::Size,
    pub trimmed: bool,
    pub sprite_source_size: Option<crate::pack::rect::Rect>,
}

impl Default for Lockfile {
    fn default() -> Self {
        Self {
            version: 3,
            inputs: BTreeMap::new(),
        }
    }
}

impl Lockfile {
    pub fn get(&self, input_name: &str, hash: &str) -> Option<&LockfileEntry> {
        self.inputs.get(input_name).and_then(|m| m.get(hash))
    }

    pub fn insert(&mut self, input_name: &str, hash: &str, entry: LockfileEntry) {
        self.inputs
            .entry(input_name.to_string())
            .or_default()
            .insert(hash.to_owned(), entry);
    }

    pub async fn write(&self, filename: Option<&Path>) -> Result<()> {
        let mut content = toml::to_string(self)?;
        content.insert_str(0, "# This file is automatically @generated by Asphalt.\n# It is not intended for manual editing.\n");

        fs::write(filename.unwrap_or(Path::new(FILE_NAME)), content).await?;
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OldLockfileEntry {
    pub hash: String,
    pub asset_id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LockfileV0 {
    entries: BTreeMap<PathBuf, OldLockfileEntry>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LockfileV1 {
    version: u32,
    inputs: BTreeMap<String, BTreeMap<PathBuf, OldLockfileEntry>>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LockfileV2Entry {
    pub asset_id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LockfileV2 {
    version: u32,
    inputs: BTreeMap<String, BTreeMap<String, LockfileV2Entry>>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RawLockfile {
    V0(LockfileV0),
    V1(LockfileV1),
    V2(LockfileV2),
    V3(Lockfile),
}

impl Default for RawLockfile {
    fn default() -> Self {
        Self::V3(Lockfile::default())
    }
}

impl RawLockfile {
    pub async fn read() -> Result<RawLockfile> {
        let content = fs::read_to_string(FILE_NAME).await;

        let content = match content {
            Err(_) => return Ok(Self::default()),
            Ok(content) => content,
        };

        let raw: toml::Value = toml::from_str(&content)?;

        match raw.get("version").and_then(|v| v.as_integer()) {
            Some(3) => Ok(RawLockfile::V3(toml::from_str(&content)?)),
            Some(2) => Ok(RawLockfile::V2(toml::from_str(&content)?)),
            Some(1) => Ok(RawLockfile::V1(toml::from_str(&content)?)),
            Some(0) | None => Ok(RawLockfile::V0(toml::from_str(&content)?)),
            _ => bail!("Unsupported lockfile version"),
        }
    }

    pub fn into_lockfile(self) -> anyhow::Result<Lockfile> {
        match self {
            Self::V3(lockfile) => Ok(lockfile),
            Self::V2(v2) => Ok(migrate_from_v2(&v2)),
            _ => anyhow::bail!("Your lockfile is out of date, please run asphalt migrate-lockfile"),
        }
    }

    pub async fn migrate(self, input_name: Option<&str>) -> Result<Lockfile> {
        match (self, input_name) {
            (Self::V3(_), _) => bail!("Your lockfile is already up to date"),
            (Self::V2(v2), _) => Ok(migrate_from_v2(&v2)),
            (Self::V1(v1), _) => Ok(migrate_from_v1(&v1)),
            (Self::V0(v0), Some(name)) => migrate_from_v0(&v0, name).await,
            (Self::V0(_), None) => {
                bail!("An input name must be passed in order to migrate from v0 to v1")
            }
        }
    }
}

fn migrate_from_v2(lockfile: &LockfileV2) -> Lockfile {
    let mut new_lockfile = Lockfile::default();

    for (input_name, entries) in &lockfile.inputs {
        for (hash, entry) in entries {
            new_lockfile.insert(
                input_name,
                hash,
                LockfileEntry {
                    asset_id: entry.asset_id,
                    sprite_info: None,
                },
            )
        }
    }

    new_lockfile
}

fn migrate_from_v1(lockfile: &LockfileV1) -> Lockfile {
    let mut new_lockfile = Lockfile::default();

    for (input_name, entries) in &lockfile.inputs {
        for entry in entries.values() {
            new_lockfile.insert(
                input_name,
                &entry.hash,
                LockfileEntry {
                    asset_id: entry.asset_id,
                    sprite_info: None,
                },
            )
        }
    }

    new_lockfile
}

async fn migrate_from_v0(lockfile: &LockfileV0, input_name: &str) -> anyhow::Result<Lockfile> {
    let mut new_lockfile = Lockfile::default();

    for (path, entry) in &lockfile.entries {
        let new_hash = read_and_hash(path)
            .await
            .context(format!("Failed to hash {}", path.display()))?;

        new_lockfile.insert(
            input_name,
            &new_hash,
            LockfileEntry {
                asset_id: entry.asset_id,
                sprite_info: None,
            },
        )
    }

    Ok(new_lockfile)
}

async fn read_and_hash(path: &Path) -> Result<String> {
    let bytes = fs::read(path).await?;
    let mut hasher = Hasher::new();
    hasher.update(&bytes);
    Ok(hasher.finalize().to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::pack::rect::{Rect, Size};

    fn create_sprite_info(trimmed: bool) -> SpriteInfo {
        SpriteInfo {
            rect: Rect::new(10, 20, 64, 64),
            source_size: Size::new(64, 64),
            trimmed,
            sprite_source_size: if trimmed {
                Some(Rect::new(5, 5, 54, 54))
            } else {
                None
            },
        }
    }

    #[test]
    fn test_lockfile_with_sprite_info() {
        let mut lockfile = Lockfile::default();

        let entry_with_sprite = LockfileEntry {
            asset_id: 12345,
            sprite_info: Some(create_sprite_info(true)),
        };

        let entry_without_sprite = LockfileEntry {
            asset_id: 67890,
            sprite_info: None,
        };

        lockfile.insert("images", "hash1", entry_with_sprite.clone());
        lockfile.insert("images", "hash2", entry_without_sprite.clone());

        let retrieved_with = lockfile.get("images", "hash1").unwrap();
        assert_eq!(retrieved_with.asset_id, 12345);
        assert!(retrieved_with.sprite_info.is_some());
        let sprite_info = retrieved_with.sprite_info.as_ref().unwrap();
        assert_eq!(sprite_info.rect.x, 10);
        assert_eq!(sprite_info.rect.y, 20);
        assert_eq!(sprite_info.rect.width, 64);
        assert_eq!(sprite_info.rect.height, 64);
        assert!(sprite_info.trimmed);
        assert!(sprite_info.sprite_source_size.is_some());

        let retrieved_without = lockfile.get("images", "hash2").unwrap();
        assert_eq!(retrieved_without.asset_id, 67890);
        assert!(retrieved_without.sprite_info.is_none());
    }

    #[test]
    fn test_lockfile_sprite_info_serialization() {
        let mut lockfile = Lockfile::default();

        lockfile.insert(
            "spritesheets",
            "hash_trimmed",
            LockfileEntry {
                asset_id: 11111,
                sprite_info: Some(create_sprite_info(true)),
            },
        );

        lockfile.insert(
            "spritesheets",
            "hash_untrimmed",
            LockfileEntry {
                asset_id: 22222,
                sprite_info: Some(create_sprite_info(false)),
            },
        );

        lockfile.insert(
            "images",
            "hash_regular",
            LockfileEntry {
                asset_id: 33333,
                sprite_info: None,
            },
        );

        let serialized = toml::to_string(&lockfile).expect("Failed to serialize");

        assert!(serialized.contains("asset_id = 11111"));
        assert!(serialized.contains("asset_id = 22222"));
        assert!(serialized.contains("asset_id = 33333"));
        assert!(serialized.contains("trimmed = true"));
        assert!(serialized.contains("trimmed = false"));
        assert!(serialized.contains("sprite_info"));
        assert!(serialized.contains("rect"));
        assert!(serialized.contains("source_size"));

        let deserialized: Lockfile = toml::from_str(&serialized).expect("Failed to deserialize");

        let trimmed_entry = deserialized.get("spritesheets", "hash_trimmed").unwrap();
        assert_eq!(trimmed_entry.asset_id, 11111);
        assert!(trimmed_entry.sprite_info.is_some());
        assert!(trimmed_entry.sprite_info.as_ref().unwrap().trimmed);
        assert!(trimmed_entry
            .sprite_info
            .as_ref()
            .unwrap()
            .sprite_source_size
            .is_some());

        let untrimmed_entry = deserialized.get("spritesheets", "hash_untrimmed").unwrap();
        assert_eq!(untrimmed_entry.asset_id, 22222);
        assert!(untrimmed_entry.sprite_info.is_some());
        assert!(!untrimmed_entry.sprite_info.as_ref().unwrap().trimmed);
        assert!(untrimmed_entry
            .sprite_info
            .as_ref()
            .unwrap()
            .sprite_source_size
            .is_none());

        let regular_entry = deserialized.get("images", "hash_regular").unwrap();
        assert_eq!(regular_entry.asset_id, 33333);
        assert!(regular_entry.sprite_info.is_none());
    }

    #[test]
    fn test_lockfile_insert_multiple_inputs() {
        let mut lockfile = Lockfile::default();

        lockfile.insert(
            "input1",
            "hash_a",
            LockfileEntry {
                asset_id: 100,
                sprite_info: Some(create_sprite_info(true)),
            },
        );

        lockfile.insert(
            "input1",
            "hash_b",
            LockfileEntry {
                asset_id: 200,
                sprite_info: Some(create_sprite_info(false)),
            },
        );

        lockfile.insert(
            "input2",
            "hash_c",
            LockfileEntry {
                asset_id: 300,
                sprite_info: None,
            },
        );

        assert_eq!(lockfile.get("input1", "hash_a").unwrap().asset_id, 100);
        assert_eq!(lockfile.get("input1", "hash_b").unwrap().asset_id, 200);
        assert_eq!(lockfile.get("input2", "hash_c").unwrap().asset_id, 300);
        assert!(lockfile.get("input1", "hash_c").is_none());
        assert!(lockfile.get("input3", "hash_a").is_none());
    }

    #[test]
    fn test_sprite_info_edge_cases() {
        let mut lockfile = Lockfile::default();

        let max_values_sprite = SpriteInfo {
            rect: Rect::new(u32::MAX, u32::MAX, u32::MAX, u32::MAX),
            source_size: Size::new(u32::MAX, u32::MAX),
            trimmed: true,
            sprite_source_size: Some(Rect::new(0, 0, u32::MAX, u32::MAX)),
        };

        lockfile.insert(
            "test",
            "max_values",
            LockfileEntry {
                asset_id: u64::MAX,
                sprite_info: Some(max_values_sprite),
            },
        );

        let retrieved = lockfile.get("test", "max_values").unwrap();
        assert_eq!(retrieved.asset_id, u64::MAX);
        let sprite = retrieved.sprite_info.as_ref().unwrap();
        assert_eq!(sprite.rect.x, u32::MAX);
        assert_eq!(sprite.source_size.width, u32::MAX);

        let zero_values_sprite = SpriteInfo {
            rect: Rect::new(0, 0, 1, 1),
            source_size: Size::new(1, 1),
            trimmed: false,
            sprite_source_size: None,
        };

        lockfile.insert(
            "test",
            "zero_values",
            LockfileEntry {
                asset_id: 0,
                sprite_info: Some(zero_values_sprite),
            },
        );

        let retrieved = lockfile.get("test", "zero_values").unwrap();
        assert_eq!(retrieved.asset_id, 0);
        let sprite = retrieved.sprite_info.as_ref().unwrap();
        assert_eq!(sprite.rect.x, 0);
        assert_eq!(sprite.rect.y, 0);
    }
}
